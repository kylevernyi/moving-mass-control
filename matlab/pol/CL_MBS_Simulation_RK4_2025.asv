%{ 
WORKING SIMULATION!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

Project:      MSAE Thesis - Adaptive Control & Estimation of Spacecraft 
                            Mass Properties Utilizing Moving Masses
File:         MBS_Simulation_RK4_09_10_2024.m
Author:       Pol Fontdegloria Balaguer Kyle
Supervisor:   Dr. Riccardo Bevilacqua
Laboratory:   ADAMUS Laboratory
University:   Embry-Ri-ddle Aeronautical University
Date:         September 10th 2024 
Description:  Simulation of Adaptive Control Law for estimation of Center 
              of Mass of a 5-DOF Testbed under gravity torque due to the
              offset between CoM and CoR. Use of a RK4 integrator to
              propagate the dynamics of the system. This script has a
              predefined desired trajectory as a function of t.
%}

clc; clear; clear global variables; clear mbs_ode_traj; close all; clear all;
rng(1);

format long;

% Load Directories
% cd('\Users\fontd\OneDrive\Desktop\ERAU (MS)\AE 700\Simulations\5-DOF Simulations\Mass Balancing System');
addpath('Functions');
addpath('Functions/DualQuaternionFunctions');

%% Call Global Variables6
global point_added min_sv;
global ESS omega_b2i_B_est; % particle filter
global xhat xhat_original L lambda P_smoother Sigma Pi omega_b2i_B_meas; % fixed point kalman filter
global u_com r_com; % zero order hold

global omega_dot; % for derivative testing
omega_dot =[];
%% Select Integration Parameters
t_0 = 0; dt = 0.01; t_max = 50;
T = t_0:dt:t_max; % in seconds

%% Gains in Control Law u
K = 1e-6; % Derivative
alpha = 1e-6*diag([1,1,1]); % proportional gain
gamma = 1e-5*diag([1 1 1]); % Learning Rate in Estimation Law

A = pi/3; % Desired Oscillation Amplitude

% Concurrent learning gains
CL_on = 1; 
CL_point_accept_epsilon = 0.01; % Threshold to accept new points
p_bar = 10; % maximum number of points stored
CL_gain = .01*inv(gamma)/p_bar; 

% Fixed point smoothing parameters
H = [eye(3), zeros(3,3)];
Phi_stm = expm([zeros(3,3), eye(3); zeros(3,6)]*dt); % state transistion matrix for kalman filter
v_smooth = 30; % how many future points to include in smoothing

%% Spacecraft mechanical parameters
Jxx = 0.0226; Jyy = 0.0226; Jzz = 0.0226; %  Moment of Inertia Matrix
J0 = diag([Jxx Jyy Jzz]);
M = 4.2; % Simulator mass
m1 = 0.3; m2 = 0.3; m3 = 0.3; % Actuator mass
m = diag([m1,m2,m3]);
g_I = [0;0;-9.81]; % Gravity vector
motor_bandwidth_hz = 10*eye(3);

% Sensor Noise VN-100 (IMU) - Add if needed
omega_noise_on = 1;
SR = 100; % Maximum Sample Rate in Hz
ND = 0.0035*pi/180; % Noise Density of Gyroscope in rad
sigma_omega = ND*sqrt(SR); % Noise Standard Deviation



%% Initial Conditions
omega_b2i_B_0 = [0.0288;0.01229;0.013611];
% omega_b2i_B_0 = 0.05*randn(3,1);
q_i2b_0 = [1;0;0;0];%[0.484125,0.017008,0.125903,-0.86573]';
euler_0 = quat2eul(q_i2b_0','ZYX');
q_i2d_0 = [1;0;0;0];%eul2quat([euler_0(1),0,0],'ZYX')';
theta_hat_0 = [0;0;0];
r_masses_0 = zeros(3,1); % position of the masses relative to the center of rotation
% JB_m_0 = zeros(3,1); % sliding mass initial moment of intertia
% Obtain the initial angular rates of the BFF w.r. to Inertial in the Inertial Frame
omega_b2i_I_0 = quat_mult(quat_mult(q_i2b_0,[0;omega_b2i_B_0]),quat_conj(q_i2b_0));
omega_b2i_I_0 = omega_b2i_I_0(2:4);
% Define the initial angular rates of the DF w.r. to Inertial in the DF by rotating the vector from the Inertial to DF 
omega_d2i_D_0 = quat_mult(quat_mult(quat_conj(q_i2d_0),[0;0;0;omega_b2i_I_0(3)]),q_i2d_0);

% Initial offset from CoR to CoM in (m)
theta = [3.3;-2.2;4.7]*10^-3;

% Initial conditions
IC = [q_i2b_0;omega_b2i_B_0;theta_hat_0;q_i2d_0; r_masses_0];  % IC vector State Vector
X = zeros(length(IC),length(T));
X(:,1) = IC;
xin = IC;

%% Start of Dynamics Intgegration
dynamicsFunction = @(t,x) mbs_ode_traj(t, x, J0, M, m, g_I, theta, gamma, K, alpha, sigma_omega,  A, motor_bandwidth_hz, ...
    omega_b2i_I_0, ... 
    CL_gain, CL_on, p_bar, CL_point_accept_epsilon, omega_noise_on,  ...
    Phi_stm, H, v_smooth, ...
    true);
backsolvingFunction = @(t,x) mbs_ode_traj(t, x, J0, M, m, g_I, theta, gamma, K, alpha, sigma_omega,  A, motor_bandwidth_hz, ...
    omega_b2i_I_0, ... 
    CL_gain, CL_on, p_bar, CL_point_accept_epsilon, omega_noise_on,  ...
    Phi_stm, H, v_smooth, ...
    false);

for i = 2:1:length(T)
    time = i*dt;

    xkplus1 = rk4_singlestep(dynamicsFunction, dt, time, xin);
    X(:,i) = xkplus1;
    xin = xkplus1;
end
r_masses_actual = X(15:17,:);

% Back solve for all intermediary variables useful in analysis
[~,U] = cellfun(backsolvingFunction, num2cell(T), num2cell(X,1),'UniformOutput',0); 
misc_signals = [];
for i = 1:length(U)
    cellArray = U(i);  
    misc_signals(i, :) = cell2mat(cellArray');  % Convert and transpose to row
end
% U = [omega_b2i_I_0' omega_b2d_B' omega_d2i_D' q_d2b' omega_b2i_I'  r'];
omega_b2i_I_0 = misc_signals(:, 1:3);
omega_b2d_B = misc_signals(:, 4:6);
omega_d2i_D = misc_signals(:, 7:9);
q_d2b = misc_signals(:, 10:13);
omega_b2i_I = misc_signals(:, 14:16);
r_error = misc_signals(:,17:19);  % auxillary error signal

% extract more variables
omega_hat_smooth = xhat(1:3, :);
omega_dot_hat_smooth = xhat(4:6, :);
omega_hat = xhat_original(1:3, :);
omega_dot_hat = xhat_original(4:6, :);

% Kalman error calculations
e_kalman = X(1:6,:) - xhat_original;
e_smoothed = X(1:6,:) - xhat;
e_meas = X(5:7,2:end) - omega_b2i_B_meas;

%% Save Data (for long simulations)
% filename = sprintf('Simulation Data/RK4 Simulation Data/step_%g_time_%g_K_%g_gamma_%g_%g_%g.mat',...
%     dt,t_max,Kd,gamma(1,1),gamma(2,2),gamma(3,3));
% save(filename,"T","X","Rs")

%% Plotting
plot_results;










%% Dynamics function
function [x_dot, U] = mbs_ode_traj(t, x, J0, M, m, g_I, theta, gamma, K, alpha, sigma_omega,  A, motor_bandwidth_hz, ...
    omega_b2i_I_0, ... 
    CL_gain, CL_on, p_bar, CL_point_accept_epsilon, omega_noise_on,  ...
    Phi_stm, H, v_smooth, ...
    integration_phase) 
%% Control variables that are used on whole timesteps
global u_com r_com; 
persistent u_com_local r_com_local; % zero order hold
persistent w_iter ; % whole step iterations 
%% Concurrent learning variables 
global point_added min_sv;
persistent Tau_ext_stack Phi_stack Theta_hat_stack;
persistent Phi_last_point_stored p;
persistent current_index_for_cyclic_stack rk4_counter xdot_hat_available;
% Particle filter variables
% global ESS omega_b2i_B_est;
% persistent  particles N ; 
% N = 1000; % number of particles in particle filter
% Kalman filter variables
global xhat xhat_original L lambda P_smoother Sigma Pi omega_b2i_B_meas kf_iter;
persistent j_smooth ;

Q = [0.001*eye(3), zeros(3,3);
    zeros(3,3), 10*eye(3)]; % Process noise covariance
R = sigma_omega^2*eye(3); % Measurement noise covariance

global omega_dot; % for derivative testing

%% Initilization
if isempty(rk4_counter)
    rk4_counter = 0
    w_iter = 1; % only whole step iterations
end

if(mod(rk4_counter, 4) == 0) % used to see if we should run controller and filter or just run dynamics
    whole_timestep = true;
else 
    whole_timestep = false;
end

     

%% Retrieve State Variables
x = reshape(x, [length(x) 1]);

q_i2b = x(1:4); q_i2b = q_i2b/norm(q_i2b);
omega_b2i_B = x(5:7);
theta_hat = x(8:10);
q_i2d = x(11:14); q_i2d = q_i2d/norm(q_i2d);
r_masses = x(15:17); % retrieve the position of the sliding masses

%% Initialize kalman filter
if isempty(xhat)
    % xhat = [omega; omega_dot];
    xhat = [omega_b2i_B; zeros(3,1)]; % initialize kalman filter to state
    P_smoother = [1*eye(3), zeros(3,3); 
                  zeros(3,3),  1e6*eye(3)]; % initial covariance matrix;
    kf_iter = 1;
    j_smooth = 10;
    xdot_hat_available = false;
end



%% Make measurements on state variables
meas_noise =  omega_noise_on*sqrtm(R)*randn(3,1);
if (whole_timestep && integration_phase)
    omega_b2i_B_meas(:,kf_iter) = omega_b2i_B + meas_noise;   % only make measurements on whole time steps
end
omega_b2i_B_noise = omega_b2i_B + meas_noise; % same as above but we use this in dynamics every time step including substeps

%% Kalman filter with fixed point smoother
% Regular apriori kalman filter runs every time step
if (whole_timestep && integration_phase)
    if (kf_iter < j_smooth)  % regular kalman filter until we turn on fps
        
        L(:,:,kf_iter) = (Phi_stm*P_smoother(:,:,kf_iter)*H') / (H*P_smoother(:,:,kf_iter)*H' + R); % gain
        xhat(:,kf_iter+1) = Phi_stm*xhat(:,kf_iter) + L(:,:,kf_iter)*(omega_b2i_B_meas(:,kf_iter) - H*xhat(:,kf_iter)); % update
        P_smoother(:,:, kf_iter+1) = Phi_stm*P_smoother(:,:,kf_iter) * (Phi_stm - L(:,:,kf_iter)*H)' + Q; % update
        xhat_original(:,kf_iter+1) =  xhat(:,kf_iter+1); % save for comparison
        % xdot_hat_available = true;
    
    elseif (kf_iter >= j_smooth) % we need to at least be to the jth point to start smoothing
        % Fixed point smoother initialization
        Sigma(:,:,j_smooth) = P_smoother(:,:,j_smooth);
        Pi(:,:,j_smooth) = P_smoother(:,:,j_smooth);
    
        for k = j_smooth:1:kf_iter % iterate from oldest point to smooth (j_smooth) to current measurement (kf_iter)
            L(:,:,k) = (Phi_stm*P_smoother(:,:,k)*H') /(H*P_smoother(:,:,k)*H' + R);
    
            lambda(:,:, k) = (Sigma(:,:,k)*H') / (H*P_smoother(:,:,k)*H' + R); % smoother kalman gain
            
            xhat(:, j_smooth) = xhat(:,j_smooth) + lambda(:,:,k) * (omega_b2i_B_meas(:,k) - H*xhat(:,k)); % updating previous estimates here, note j_smooth
    
            xhat(:,k+1) = Phi_stm*xhat(:,k) + L(:,:,k)*(omega_b2i_B_meas(:,k) - H*xhat(:,k));
            P_smoother(:,:, k+1) = Phi_stm*P_smoother(:,:,k) * (Phi_stm - L(:,:,k)*H)' + Q;
    
            % Propagate covariance (Pi) and cross variance (sigma). 
            % We mostly care to inspect Pi. sigma is an intermediate variable
            Pi(:,:,k+1) = Pi(:,:,k) - Sigma(:,:,k)*H'*lambda(:,:,k)';
            Sigma(:,:,k+1) = Sigma(:,:,k)*(Phi_stm - L(:,:,k)*H)';
    
            % enforce symmetry
            % Sigma(:,:,k+1) = 0.5 * (Sigma(:,:,k+1) + Sigma(:,:,k+1)');
            % Pi(:,:,k+1) = 0.5 * (Pi(:,:,k+1) + Pi(:,:,k+1)');
    
            xhat_original(:,k+1) =  xhat(:,k+1); % save for comparison
        end
        xdot_hat_available = true;
    end


    % if current point is more than "v" points away from the oldest smoothed point  
    % we move our oldest point up to smooth the next point
    if ( (kf_iter+1) - j_smooth ) > v_smooth
        j_smooth = j_smooth+1;
    end

end

%% Predefined Omega and Quaternion Trajectory w.r. to Inertial Frame
b = 0.01*pi; f = 0.01;
omega_b2i_I = quat_mult(quat_mult(q_i2b,[0;omega_b2i_B]),quat_conj(q_i2b));
omega_b2i_I = omega_b2i_I(2:4);
omega_d2i_I = [0;0;omega_b2i_I_0(3)]; % Angular rates of DF w.r. Inertial in Inertial Frame

% Transformation Rotation of Angular Rates of the DF w.r. to Inertial from Inertial to DF
omega_d2i_D = quat_mult(quat_mult(quat_conj(q_i2d),[0;omega_d2i_I]),q_i2d);
omega_d2i_D = omega_d2i_D(2:4);

omega_dot_d2i_D = [0;0*A*exp(-f*t)*(f*sin(b*t) - b*cos(b*t));0];
omega_dot_d2i_I = quat_mult(quat_mult(q_i2d,[0;omega_dot_d2i_D]), quat_conj(q_i2d));
omega_dot_d2i_I = omega_dot_d2i_I(2:4);
omega_dot_d2i_B = quat_mult(quat_mult(quat_conj(q_i2b),[0;omega_dot_d2i_I]),q_i2b);
omega_dot_d2i_B = omega_dot_d2i_B(2:4);

%% Error signals from Body to Desired
q_d2b = quat_mult(quat_conj(q_i2d),q_i2b);
% Omega Desired w.r. Inertial in Body Fixed Frame (BFF)
omega_d2i_B = quat_mult(quat_mult(quat_conj(q_d2b),[0;omega_d2i_D]),q_d2b);
omega_d2i_B = omega_d2i_B(2:4);


omega_b2d_B = omega_b2i_B - omega_d2i_B; % Omega Body w.r. Desired in BFF
omega_b2d_B_control = xhat(1:3,kf_iter) - omega_d2i_B; % Omega Body w.r. Desired in BFF that has noise influece, used in control signal

r = omega_b2d_B_control + alpha*q_d2b(2:4); % Definition of r error signal


%% Update of J(t) as a function of new mass position
sigma = r_masses;
JB_m = diag([sigma(2)^2 + sigma(3)^2, sigma(1)^2 + sigma(3)^2, sigma(1)^2 + sigma(2)^2]);
J = J0  + JB_m;

sigma_dot = zeros(3,1);
JB_m_dot = 2*[sigma(2)*sigma_dot(2) + sigma(3)*sigma_dot(3), ...
                    sigma(1)*sigma_dot(1) + sigma(3)*sigma_dot(3), ...
                    sigma(1)*sigma_dot(1) + sigma(2)*sigma_dot(2)];% moment of inertia rate of change due to sliding masses (as a 3x1 vector)

%% Transformation of Gravity Vector from Inertial to BFF
g_B = quat_mult(quat_mult(quat_conj(q_i2b),[0;g_I]),q_i2b);
g_B = g_B(2:4);
g_b_x = skew(g_B); % Skew Matrix of Gravity Vector in BFF
Phi = -M*g_b_x; % Phi definition as in ref[DOI: 10.2514/1.60380]

%% Control Torque as Designed by Lyapunov Analysis ONLY ON WHOLE TIME STEPS
P = (eye(3)-(g_B*g_B')/(norm(g_B)^2));
if (whole_timestep && integration_phase)
    % Without kalman filter use noisy measurements only
    % u_com(:,kf_iter) = P*cross(omega_b2i_B_noise,J*omega_b2i_B_noise) - P*Phi*theta_hat...
    %     + J*P*(omega_dot_d2i_B + cross(omega_d2i_B,omega_b2d_B)...
    %     - 0.5*alpha*(skew(q_d2b(2:4)) + q_d2b(1)*eye(3))*omega_b2d_B)...
    %     - K*P*r - diag((P*theta_hat).^2)*r;

    % use kalman filter estimates 
    omega_b2i_B_est = xhat(1:3,kf_iter+1);
    u_com(:,w_iter) = P * (-JB_m_dot*(0.5*r - omega_b2i_B_est) + cross(omega_b2i_B_est,J*omega_b2i_B_est) - Phi*theta_hat - K*r - diag((theta_hat).^2)*r) ...
    + P*J*(omega_dot_d2i_B + cross(omega_d2i_B,omega_b2d_B) - 0.5*alpha*(skew(q_d2b(2:4)) + q_d2b(1)*eye(3))*omega_b2d_B); % desired torque 

    u_com_local = u_com(:,w_iter); % for zero order hold

    % Transformation of u_com to Commanded Positions as in ref[DOI: 10.2514/1.60380]
    r_com(:,w_iter) = m\(cross(g_B, u_com_local)/(norm(g_B)^2)); % commanded mass positions
    r_com_local = r_com(:,w_iter); % commanded mass positions
end

%% Concurrent learning data selection algorithm
% Initialize concurrent learning persistent variables 
if (isempty(Phi_last_point_stored))  % initialize if we are just starting
    Phi_last_point_stored = Phi(:);
    p = 0;
    current_index_for_cyclic_stack = 1;
end

if (CL_on && whole_timestep && integration_phase)  % only do this if integrating not backsolving since global vars get messed up 
    if (xdot_hat_available)

        new_stack = [Phi_stack, Phi(:)];
        omega_hat = xhat(1:3, :);
        omega_dot_hat = xhat(4:6, :);
        if (  ( norm(Phi(:) - Phi_last_point_stored)^2 / norm(Phi(:)) >= CL_point_accept_epsilon)  || (rank(new_stack) > rank(Phi_stack))) 
            % omega_b2i_B_dot = J\(- cross(omega_b2i_B,J*omega_b2i_B) + Phi*theta + u_com_local) ; % Omega_dot Body w.r. Inertial in Body Frame 
            % omega_b2i_B_dot_hat = J\ (- cross(omega_hat(:,rk4_iter),J*omega_hat(:,rk4_iter)) + Phi*theta_hat + u_com_local); % Omega_dot Body w.r. Inertial in Body Frame
    
            Tau_ext_j = J*omega_dot_hat(:,w_iter) +  cross(omega_hat(:,w_iter),J*omega_hat(:,w_iter)) - u_com(:,w_iter);
            % Tau_ext_j = J*omega_b2i_B_dot+  cross(omega_hat(:,kf_iter),J*omega_hat(:,kf_iter)) - u_com_local;
            % Tau_ext_j = J*omega_b2i_B_dot_hat+  cross(omega_hat(:,kf_iter),J*omega_hat(:,kf_iter)) - u_com_local;
    
            if (p < p_bar) % Initilization, record more data until p_bar points
                p = p+1;
                current_index_for_cyclic_stack = p;
                Tau_ext_stack(:, p) = Tau_ext_j;
                Phi_stack(:, p) = Phi(:);
                Theta_hat_stack(:,p) = theta_hat;
                Phi_last_point_stored = Phi(:);
            else
                % Cyclic history stack
                [Phi_stack, ~] = updateHistoryStack(Phi_stack, current_index_for_cyclic_stack, Phi(:), p_bar);
                [Theta_hat_stack,~] = updateHistoryStack(Theta_hat_stack, current_index_for_cyclic_stack, theta_hat, p_bar);
                [Tau_ext_stack, current_index_for_cyclic_stack] = updateHistoryStack(Tau_ext_stack, current_index_for_cyclic_stack, Phi*theta, p_bar);
            end 
    
            point_added = [point_added t]; %  record that we stored a point
        end % sufficient change or adding data check end
    end % xdot_hat available
end
%% Concurrent learning error signals 
concurrent_learning_Tau_ext = zeros(3,1); % initialize sum to zero
epsilon_Tau_ext = zeros(3,p);
for j = 1:p
    Tau_ext_j = Tau_ext_stack(:,j); % jth delta from storage
    Phi_j = reshape(Phi_stack(:, j), 3, 3); % jth phi matrix from storage
    theta_hat_j = Theta_hat_stack(:,j);

    % epsilon_Tau_ext(:,j) = Phi_j*theta_hat - Tau_ext_j; % units of meters actually
    epsilon_Tau_ext(:,j) = Phi_j*theta_hat_j - Tau_ext_j;

    concurrent_learning_Tau_ext = concurrent_learning_Tau_ext + Phi_j*epsilon_Tau_ext(:,j);  
end

%%  Dynamics

q_i2b_dot = 0.5*quat_mult(q_i2b,[0;omega_b2i_B]); % q_dot of BFF w.r. to Inertial Frame
omega_b2i_B_dot = J\(-JB_m_dot*omega_b2i_B - cross(omega_b2i_B,J*omega_b2i_B) + Phi*theta + u_com_local) + sqrtm(Q(1:3,1:3))*randn(3,1)*0; % Omega_dot Body w.r. Inertial in Body Frame
q_i2d_dot = 0.5*quat_mult(q_i2d,[0;omega_d2i_D]); % q_dot of DF w.r. to Inertial Frame
theta_hat_dot = gamma* ( (Phi'*r)  + CL_on*CL_gain*concurrent_learning_Tau_ext); %  Adaptive update law
r_masses_dot = 2*pi*motor_bandwidth_hz * (r_com_local - r_masses); % first order actuator dynamics (lambda * (setpoint - current)


x_dot = [q_i2b_dot;omega_b2i_B_dot;theta_hat_dot;q_i2d_dot;r_masses_dot];
U = [omega_b2i_I_0' omega_b2d_B' omega_d2i_D' q_d2b' omega_b2i_I' r'];

if (whole_timestep && integration_phase)
    omega_dot = [omega_dot omega_b2i_B_dot];
    kf_iter = kf_iter + 1;
    w_iter = w_iter + 1;
end

%% Concurrent learning helpers
% Record the MinSVD
if (whole_timestep && (rank(Phi_stack) > 1) && integration_phase)
    min_svd = min(svd(Phi_stack,"vector"));
    if isempty(min_svd)
        min_sv = [min_sv 0];
    else
        min_sv =  [min_sv min_svd];
    end
end

rk4_counter = rk4_counter + 1;

% helper for cyclic stack
function [history, currentIndex] = updateHistoryStack(history, currentIndex, newElement, p_bar)
    history(:,currentIndex) = newElement;    % Insert the new element at the current index
    currentIndex = mod(currentIndex, p_bar) + 1;     % Update the current index in a cyclic manner
end
end

