
%% Dynamics
function [xdot_return, U_return] = mrac_dynamics(t, x, A, B, Ar, Br, P, ...
    gamma_x, gamma_R, epsilon, p_bar, CL_on, CL_K_gain, CL_Kr_gain, Kr_star, K_star)
    global point_added min_sv;
    persistent X;
    persistent R;
    persistent U;
    persistent X_dot;
    persistent x_last_point_stored;
    persistent p;
    persistent current_index_for_cyclic_stack;

    % unpack states 
    x = reshape(x, [length(x) 1]);
    xr = x(3:4);
    K = x(5:6);
    Kr = x(7);
    x = x(1:2);

    %% Reference signal
    if (t < 2)  
        r = 10;
    elseif (t >= 2 && t <= 7) 
        r = -10;
    elseif (t > 7) 
        r = 10;
    end
    
    %% Control
    e = x - xr; % tracking error signal
    K_tilde = K - K_star; % estimation errors (used for analysis not controller)
    Kr_tilde = Kr - Kr_star; 


    u_pd = K' * x; % state feedback part of control signal
    u_rm = Kr' * r; % feed forward part of control signal
    u = u_pd + u_rm; % control signal
    xdot = A*x+B*u; % pre calculate this since we use it in CL

    if (isempty(x_last_point_stored)) % initialize if we are just starting
        x_last_point_stored = x;
        p = 0;
        current_index_for_cyclic_stack = 1;
    end

    %% Concurrent learning data selection algorithm
    if (  ( norm(x - x_last_point_stored)^2 / norm(x) >= epsilon)  || (rank([X, x]) > rank(X))) 
        if (p < p_bar) % Initilization, record more data until p_bar points
            p = p+1;
            current_index_for_cyclic_stack = p;
            X(:, p) = x;
            R(:, p) = r;
            U(:, p) = u; 
            X_dot(:, p) = xdot;
            x_last_point_stored = x;
            point_added = [point_added t];
        else

            % Cyclic history stack
            % [X, ~] = updateHistoryStack(X, current_index_for_cyclic_stack, x, p_bar);
            % [R, ~] = updateHistoryStack(R, current_index_for_cyclic_stack, r, p_bar);
            % [U, ~] = updateHistoryStack(U, current_index_for_cyclic_stack, u, p_bar);
            % [X_dot, current_index_for_cyclic_stack] = updateHistoryStack(X_dot, current_index_for_cyclic_stack, A*x+B*u, p_bar);

            % MinSVD Maximization Algorithm (activates after p_bar points)
            % Now we only add new points if it makes our minimum singular value (msv) increase
            T = X; % temp storage of X
            S_min_old = min(svd(X, "vector")); % get the current minimum singular values

            S = zeros([p 1]); % preallocate to hold all new min sv that we are going to test
            for j = 1:p 
                % iterate through each column in X and replace it with the new data point. 
                % calculate and store the new minimum singular value for comparison later
                X(:,j) = x;
                S(j) = min(svd(X,"vector")); %store calculated min sing value
                X = T; % restore X back to its original value for the next iteration
            end

            [max_S, max_S_idx] = max(S); 
            if (max_S > S_min_old) % if any new combinations increase our minimum SV
                X(:,max_S_idx) = x; % store new x if we have increased our SV
                R(:,max_S_idx) = r;
                X_dot(:,max_S_idx) = xdot;
                U(:,max_S_idx) = u;
                x_last_point_stored = x;
                point_added = [point_added t];
            end
        end 
    % Record the MinSVD
    min_svd = min(svd(X,"vector"));
    if isempty(min_svd)
        min_sv = [min_sv 0];
    else
        min_sv =  [min_sv min_svd];
    end
    end % sufficient change or adding data check end


    %% Concurrent learning error signals 
    concurrent_learning_x = 0; % initialize sum to zero
    concurrent_learning_R = 0;
    e_Kr = zeros([p 1]);
    e_K = zeros([p 1]);
    for j = 1:p
        x_j = X(:,j); % jth state vector from storage
        r_j = R(:,j); % jth reference signal from storage
        u_j = U(:,j);
        xdot_j = X_dot(:,j); % jth derivative from storage

        e_Kr(j) = Kr'*r_j - inv(B'*B)*B'*Br*r_j;

        e_K(j) = inv(B'*B)*B' * (xdot_j  - Ar*x_j - Br*r_j - B*e_Kr(j)); %  inv(B'*B) * B' same as pinv

        concurrent_learning_x = concurrent_learning_x + x_j*e_K(j)'; 
        concurrent_learning_R = concurrent_learning_R + r_j*e_Kr(j)'; 
    end


    % dynamics and update laws
    K_dot = -gamma_x * (x*e'*P*B + CL_on*CL_K_gain*concurrent_learning_x);
    Kr_dot = -gamma_R * (r*e'*P*B + CL_on*CL_Kr_gain*concurrent_learning_R);

    xdot = A*x + B*u;
    xr_dot = Ar*xr + Br*r;
       
    V = 0.5*e'*P*e + 0.5*trace(K_tilde'*inv(gamma_x)*K_tilde) + 0.5*trace(Kr_tilde'*inv(gamma_R)*Kr_tilde); % lyap function

    xdot_return = [xdot; xr_dot; K_dot; Kr_dot];
    U_return = [u, r, u_pd, u_rm, V];



    function [history, currentIndex] = updateHistoryStack(history, currentIndex, newElement, p_bar)
    history(:,currentIndex) = newElement;    % Insert the new element at the current index
    currentIndex = mod(currentIndex, p_bar) + 1;     % Update the current index in a cyclic manner
end
end
